# .gitignore

```
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

```

# index.ts

```ts
console.log("Hello via Bun!");
```

# package.json

```json
{
  "name": "golf-serie",
  "version": "1.0.0",
  "description": "Golf Series Backend with Hexagonal Architecture",
  "module": "src/index.ts",
  "type": "module",
  "private": true,
  "scripts": {
    "dev": "bun run --watch src/index.ts",
    "prod": "bun src/index.ts",
    "build": "bun build src/index.ts --outdir=./dist",
    "test": "bun test --concurrency 1",
    "test:watch": "bun test --watch",
    "migrate": "bun run src/database/migrate.ts",
    "type-check": "tsc --noEmit",
    "lint": "eslint src/**/*.ts",
    "setup": "bun install && bun run src/database/migrate.ts && bun run src/database/seed.ts",
    "start": "bun run src/index.ts"
  },
  "dependencies": {
    "hono": "^4.7.10",
    "uuid": "^9.0.1",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/bun": "latest",
    "@types/uuid": "^9.0.7",
    "drizzle-kit": "^0.20.8",
    "typescript": "^5.3.3",
    "bun-types": "latest"
  },
  "engines": {
    "bun": ">=1.0.0"
  }
}

```

# README.md

```md
# Golf Series Backend

A simple backend system for managing golf courses, teams, and competitions.

## Technology Stack

- **Runtime**: Bun.js
- **Language**: TypeScript (strict mode)
- **Database**: SQLite3 using Bun's built-in SQLite library
- **HTTP Server**: Bun's built-in HTTP server
- **Testing**: Bun's built-in test runner

## Prerequisites

- [Bun](https://bun.sh/) installed on your system

## Setup

1. Clone the repository
2. Install dependencies:
   \`\`\`bash
   bun install
   \`\`\`
3. Run database migrations:
   \`\`\`bash
   bun run migrate
   \`\`\`

## Development

Start the development server:
\`\`\`bash
bun run dev
\`\`\`

The server will start on port 3000 by default. You can change this by setting the `PORT` environment variable.

## Testing

Run the test suite:
\`\`\`bash
bun test
\`\`\`

## API Endpoints

### Courses

- `POST /api/courses` - Create a course
- `GET /api/courses` - List all courses
- `GET /api/courses/:id` - Get single course
- `PUT /api/courses/:id` - Update a course

### Teams

- `POST /api/teams` - Create a team
- `GET /api/teams` - List all teams
- `GET /api/teams/:id` - Get single team
- `PUT /api/teams/:id` - Update team name

### Competitions

- `POST /api/competitions` - Create a competition
- `GET /api/competitions` - List all competitions
- `GET /api/competitions/:id` - Get single competition
- `PUT /api/competitions/:id` - Update a competition

## Data Models

### Course
- id (integer, primary key)
- name (text)
- pars (JSON array of 18 numbers)
- created_at, updated_at (datetime)

### Team
- id (integer, primary key)
- name (text, unique)
- created_at, updated_at (datetime)

### Competition
- id (integer, primary key)
- name (text)
- date (text/date)
- course_id (foreign key to Course)
- created_at, updated_at (datetime)

## Validation Rules

### Course
- Name is required and non-empty
- Pars must be array of exactly 18 positive integers (3-6 range)

### Team
- Name is required and non-empty
- Name must be unique

### Competition
- Name is required and non-empty
- Date is required (basic date format)
- course_id must reference existing course
```

# src/api/competitions.ts

```ts
import { CompetitionService } from "../services/competition-service";
import type { CreateCompetitionDto, UpdateCompetitionDto } from "../types";

export function createCompetitionsApi(competitionService: CompetitionService) {
  return {
    async create(req: Request): Promise<Response> {
      try {
        const data = (await req.json()) as CreateCompetitionDto;
        const competition = await competitionService.create(data);
        return new Response(JSON.stringify(competition), {
          status: 201,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async findAll(): Promise<Response> {
      try {
        const competitions = await competitionService.findAll();
        return new Response(JSON.stringify(competitions), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async findById(req: Request, id: number): Promise<Response> {
      try {
        const competition = await competitionService.findById(id);
        if (!competition) {
          return new Response(
            JSON.stringify({ error: "Competition not found" }),
            {
              status: 404,
              headers: { "Content-Type": "application/json" },
            }
          );
        }
        return new Response(JSON.stringify(competition), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async update(req: Request, id: number): Promise<Response> {
      try {
        const data = (await req.json()) as UpdateCompetitionDto;
        const competition = await competitionService.update(id, data);
        return new Response(JSON.stringify(competition), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async delete(id: number): Promise<Response> {
      try {
        await competitionService.delete(id);
        return new Response(null, { status: 204 });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 404,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async getLeaderboard(competitionId: number): Promise<Response> {
      try {
        const leaderboard = await competitionService.getLeaderboard(
          competitionId
        );
        return new Response(JSON.stringify(leaderboard), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          const status = error.message === "Competition not found" ? 404 : 400;
          return new Response(JSON.stringify({ error: error.message }), {
            status: status,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },
  };
}

```

# src/api/courses.ts

```ts
import { CourseService } from "../services/course-service";
import type { CreateCourseDto, UpdateCourseDto } from "../types";

export function createCoursesApi(courseService: CourseService) {
  return {
    async create(req: Request): Promise<Response> {
      try {
        const data = (await req.json()) as CreateCourseDto;
        const course = await courseService.create(data);
        return new Response(JSON.stringify(course), {
          status: 201,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async findAll(): Promise<Response> {
      try {
        const courses = await courseService.findAll();
        return new Response(JSON.stringify(courses), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async findById(req: Request, id: number): Promise<Response> {
      try {
        const course = await courseService.findById(id);
        if (!course) {
          return new Response(JSON.stringify({ error: "Course not found" }), {
            status: 404,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(JSON.stringify(course), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async update(req: Request, id: number): Promise<Response> {
      try {
        const data = (await req.json()) as UpdateCourseDto;
        const course = await courseService.update(id, data);
        return new Response(JSON.stringify(course), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async updateHoles(req: Request, id: number): Promise<Response> {
      try {
        const pars = (await req.json()) as number[];
        const course = await courseService.updateHoles(id, pars);
        return new Response(JSON.stringify(course), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async delete(id: number): Promise<Response> {
      try {
        await courseService.delete(id);
        return new Response(null, { status: 204 });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 404,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },
  };
}

```

# src/api/documents.ts

```ts
import { DocumentService } from "../services/document-service";
import type { CreateDocumentDto, UpdateDocumentDto } from "../types";

export function createDocumentsApi(documentService: DocumentService) {
  return {
    async create(req: Request): Promise<Response> {
      try {
        const data = (await req.json()) as CreateDocumentDto;
        const document = await documentService.create(data);
        return new Response(JSON.stringify(document), {
          status: 201,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async findAll(): Promise<Response> {
      try {
        const documents = await documentService.findAll();
        return new Response(JSON.stringify(documents), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async findById(req: Request, id: number): Promise<Response> {
      try {
        const document = await documentService.findById(id);
        if (!document) {
          return new Response(JSON.stringify({ error: "Document not found" }), {
            status: 404,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(JSON.stringify(document), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async findBySeriesId(seriesId: number): Promise<Response> {
      try {
        const documents = await documentService.findBySeriesId(seriesId);
        return new Response(JSON.stringify(documents), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async findBySeriesIdAndType(
      seriesId: number,
      type: string
    ): Promise<Response> {
      try {
        const documents = await documentService.findBySeriesIdAndType(
          seriesId,
          type
        );
        return new Response(JSON.stringify(documents), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async update(req: Request, id: number): Promise<Response> {
      try {
        const data = (await req.json()) as UpdateDocumentDto;
        const document = await documentService.update(id, data);
        return new Response(JSON.stringify(document), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async delete(id: number): Promise<Response> {
      try {
        await documentService.delete(id);
        return new Response(null, { status: 204 });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 404,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async getDocumentTypes(seriesId: number): Promise<Response> {
      try {
        const types = await documentService.getDocumentTypes(seriesId);
        return new Response(JSON.stringify(types), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async createForSeries(req: Request, seriesId: number): Promise<Response> {
      try {
        const data = (await req.json()) as { title: string; content: string };
        const document = await documentService.create({
          title: data.title,
          content: data.content,
          type: "general", // Default type for series documents
          series_id: seriesId,
        });
        return new Response(JSON.stringify(document), {
          status: 201,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async updateForSeries(
      req: Request,
      seriesId: number,
      documentId: number
    ): Promise<Response> {
      try {
        // First verify the document belongs to the series
        const document = await documentService.findById(documentId);
        if (!document) {
          return new Response(JSON.stringify({ error: "Document not found" }), {
            status: 404,
            headers: { "Content-Type": "application/json" },
          });
        }
        if (document.series_id !== seriesId) {
          return new Response(
            JSON.stringify({
              error: "Document does not belong to this series",
            }),
            {
              status: 400,
              headers: { "Content-Type": "application/json" },
            }
          );
        }

        const data = (await req.json()) as { title?: string; content?: string };
        const updatedDocument = await documentService.update(documentId, data);
        return new Response(JSON.stringify(updatedDocument), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async deleteForSeries(
      seriesId: number,
      documentId: number
    ): Promise<Response> {
      try {
        // First verify the document belongs to the series
        const document = await documentService.findById(documentId);
        if (!document) {
          return new Response(JSON.stringify({ error: "Document not found" }), {
            status: 404,
            headers: { "Content-Type": "application/json" },
          });
        }
        if (document.series_id !== seriesId) {
          return new Response(
            JSON.stringify({
              error: "Document does not belong to this series",
            }),
            {
              status: 400,
              headers: { "Content-Type": "application/json" },
            }
          );
        }

        await documentService.delete(documentId);
        return new Response(null, { status: 204 });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 404,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },
  };
}

```

# src/api/participants.ts

```ts
import { ParticipantService } from "../services/participant-service";
import type { CreateParticipantDto, UpdateParticipantDto } from "../types";

export function createParticipantsApi(participantService: ParticipantService) {
  return {
    async create(req: Request): Promise<Response> {
      try {
        const data = (await req.json()) as CreateParticipantDto;
        const participant = await participantService.create(data);
        return new Response(JSON.stringify(participant), {
          status: 201,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async findAll(): Promise<Response> {
      try {
        const participants = await participantService.findAll();
        return new Response(JSON.stringify(participants), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async findById(req: Request, id: number): Promise<Response> {
      try {
        const participant = await participantService.findById(id);
        if (!participant) {
          return new Response(
            JSON.stringify({ error: "Participant not found" }),
            {
              status: 404,
              headers: { "Content-Type": "application/json" },
            }
          );
        }
        return new Response(JSON.stringify(participant), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async update(req: Request, id: number): Promise<Response> {
      try {
        const data = (await req.json()) as UpdateParticipantDto;
        const participant = await participantService.update(id, data);
        return new Response(JSON.stringify(participant), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 404,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async delete(id: number): Promise<Response> {
      try {
        console.log("delete! /api/participants/:id", id);
        await participantService.delete(id);
        console.log("delete complete! /api/participants/:id", id);
        return new Response(null, { status: 204 });
      } catch (error) {
        console.log("delete error! /api/participants/:id", id, error);
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 404,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async findAllForCompetition(competitionId: number): Promise<Response> {
      try {
        const participants = await participantService.findAllForCompetition(
          competitionId
        );
        return new Response(JSON.stringify(participants), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async updateScore(req: Request, id: number): Promise<Response> {
      try {
        const data = (await req.json()) as { hole: number; shots: number };

        // Allow -1 (gave up) and 0 (unreported/cleared score) as valid values
        if (data.shots === undefined || data.shots === null) {
          return new Response(JSON.stringify({ error: "Shots are required" }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }

        if (!data.hole) {
          return new Response(JSON.stringify({ error: "Hole is required" }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }

        const participant = await participantService.updateScore(
          id,
          data.hole,
          data.shots
        );
        return new Response(JSON.stringify(participant), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          // Return 404 for participant not found, 400 for validation errors
          const status = error.message === "Participant not found" ? 404 : 400;
          return new Response(JSON.stringify({ error: error.message }), {
            status: status,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },
  };
}

```

# src/api/series.ts

```ts
import { SeriesService } from "../services/series-service";
import type { CreateSeriesDto, UpdateSeriesDto } from "../types";

export function createSeriesApi(seriesService: SeriesService) {
  return {
    async create(req: Request): Promise<Response> {
      try {
        const data = (await req.json()) as CreateSeriesDto;
        const series = await seriesService.create(data);
        return new Response(JSON.stringify(series), {
          status: 201,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async findAll(): Promise<Response> {
      try {
        const series = await seriesService.findAll();
        return new Response(JSON.stringify(series), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async findById(req: Request, id: number): Promise<Response> {
      try {
        const series = await seriesService.findById(id);
        if (!series) {
          return new Response(JSON.stringify({ error: "Series not found" }), {
            status: 404,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(JSON.stringify(series), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async update(req: Request, id: number): Promise<Response> {
      try {
        const data = (await req.json()) as UpdateSeriesDto;
        const series = await seriesService.update(id, data);
        return new Response(JSON.stringify(series), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async delete(id: number): Promise<Response> {
      try {
        await seriesService.delete(id);
        return new Response(null, { status: 204 });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 404,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async getCompetitions(id: number): Promise<Response> {
      try {
        const competitions = await seriesService.getCompetitions(id);
        return new Response(JSON.stringify(competitions), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async getTeams(id: number): Promise<Response> {
      try {
        const teams = await seriesService.getTeams(id);
        return new Response(JSON.stringify(teams), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async getStandings(id: number): Promise<Response> {
      try {
        const standings = await seriesService.getStandings(id);
        return new Response(JSON.stringify(standings), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async findPublic(): Promise<Response> {
      try {
        const series = await seriesService.findPublic();
        return new Response(JSON.stringify(series), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async addTeam(seriesId: number, teamId: number): Promise<Response> {
      try {
        await seriesService.addTeam(seriesId, teamId);
        return new Response(JSON.stringify({ success: true }), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async removeTeam(seriesId: number, teamId: number): Promise<Response> {
      try {
        await seriesService.removeTeam(seriesId, teamId);
        return new Response(JSON.stringify({ success: true }), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async getAvailableTeams(seriesId: number): Promise<Response> {
      try {
        const teams = await seriesService.getAvailableTeams(seriesId);
        return new Response(JSON.stringify(teams), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },
  };
}

```

# src/api/teams.ts

```ts
import { TeamService } from "../services/team-service";
import type { CreateTeamDto, UpdateTeamDto } from "../types";

export function createTeamsApi(teamService: TeamService) {
  return {
    async create(req: Request): Promise<Response> {
      try {
        const data = (await req.json()) as CreateTeamDto;
        const team = await teamService.create(data);
        return new Response(JSON.stringify(team), {
          status: 201,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async findAll(): Promise<Response> {
      try {
        const teams = await teamService.findAll();
        return new Response(JSON.stringify(teams), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async findById(req: Request, id: number): Promise<Response> {
      try {
        const team = await teamService.findById(id);
        if (!team) {
          return new Response(JSON.stringify({ error: "Team not found" }), {
            status: 404,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(JSON.stringify(team), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async update(req: Request, id: number): Promise<Response> {
      try {
        const data = (await req.json()) as UpdateTeamDto;
        const team = await teamService.update(id, data);
        return new Response(JSON.stringify(team), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },
  };
}

```

# src/api/tee-times.ts

```ts
import { TeeTimeService } from "../services/tee-time-service";
import type { CreateTeeTimeDto, UpdateTeeTimeDto } from "../types";

export function createTeeTimesApi(teeTimeService: TeeTimeService) {
  return {
    async createForCompetition(
      req: Request,
      competitionId: number
    ): Promise<Response> {
      try {
        const data = (await req.json()) as CreateTeeTimeDto;
        // Override competition_id with the one from the URL
        const teeTime = await teeTimeService.create({
          ...data,
          competition_id: competitionId,
        });
        return new Response(JSON.stringify(teeTime), {
          status: 201,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async findAllForCompetition(competitionId: number): Promise<Response> {
      try {
        const teeTimes =
          await teeTimeService.findAllForCompetitionWithParticipants(
            competitionId
          );
        return new Response(JSON.stringify(teeTimes), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (
          error instanceof Error &&
          error.message === "Competition not found"
        ) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 404,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async findById(req: Request, id: number): Promise<Response> {
      try {
        const teeTime = await teeTimeService.findById(id);
        if (!teeTime) {
          return new Response(JSON.stringify({ error: "Tee time not found" }), {
            status: 404,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(JSON.stringify(teeTime), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async findByIdWithParticipants(
      req: Request,
      id: number
    ): Promise<Response> {
      try {
        const teeTime = await teeTimeService.findByIdWithParticipants(id);
        if (!teeTime) {
          return new Response(JSON.stringify({ error: "Tee time not found" }), {
            status: 404,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(JSON.stringify(teeTime), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async update(req: Request, id: number): Promise<Response> {
      try {
        const data = (await req.json()) as UpdateTeeTimeDto;
        const teeTime = await teeTimeService.update(id, data);
        return new Response(JSON.stringify(teeTime), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async delete(id: number): Promise<Response> {
      try {
        await teeTimeService.delete(id);
        return new Response(null, { status: 204 });
      } catch (error) {
        if (error instanceof Error) {
          return new Response(JSON.stringify({ error: error.message }), {
            status: 404,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },

    async updateParticipantsOrder(req: Request, id: number): Promise<Response> {
      try {
        const body = (await req.json()) as { participantIds: number[] };
        const updatedTeeTime = await teeTimeService.updateParticipantsOrder(
          id,
          body.participantIds
        );
        return new Response(JSON.stringify(updatedTeeTime), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        if (error instanceof Error) {
          if (error.message === "Tee time not found") {
            return new Response(JSON.stringify({ error: error.message }), {
              status: 404,
              headers: { "Content-Type": "application/json" },
            });
          }
          return new Response(JSON.stringify({ error: error.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
          });
        }
        return new Response(
          JSON.stringify({ error: "Internal server error" }),
          {
            status: 500,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
    },
  };
}

```

# src/app.ts

```ts
import { Database } from "bun:sqlite";
import { Hono } from "hono";
import { cors } from "hono/cors";
import { createCompetitionsApi } from "./api/competitions";
import { createCoursesApi } from "./api/courses";
import { createDocumentsApi } from "./api/documents";
import { createParticipantsApi } from "./api/participants";
import { createSeriesApi } from "./api/series";
import { createTeamsApi } from "./api/teams";
import { createTeeTimesApi } from "./api/tee-times";
import { CompetitionService } from "./services/competition-service";
import { CourseService } from "./services/course-service";
import { DocumentService } from "./services/document-service";
import { ParticipantService } from "./services/participant-service";
import { SeriesService } from "./services/series-service";
import { TeamService } from "./services/team-service";
import { TeeTimeService } from "./services/tee-time-service";

export function createApp(db: Database): Hono {
  // Initialize services
  const courseService = new CourseService(db);
  const teamService = new TeamService(db);
  const competitionService = new CompetitionService(db);
  const teeTimeService = new TeeTimeService(db);
  const participantService = new ParticipantService(db);
  const seriesService = new SeriesService(db);
  const documentService = new DocumentService(db);

  // Initialize APIs
  const coursesApi = createCoursesApi(courseService);
  const teamsApi = createTeamsApi(teamService);
  const competitionsApi = createCompetitionsApi(competitionService);
  const teeTimesApi = createTeeTimesApi(teeTimeService);
  const participantsApi = createParticipantsApi(participantService);
  const seriesApi = createSeriesApi(seriesService);
  const documentsApi = createDocumentsApi(documentService);

  // Create Hono app
  const app = new Hono();

  // Add CORS middleware
  app.use(
    "*",
    cors({
      origin: "*",
      allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
      allowHeaders: ["Content-Type", "Authorization"],
    })
  );

  // Add request logging
  app.use("*", async (c, next) => {
    console.log(`${c.req.method} ${c.req.url}`);
    await next();
  });

  // Course routes
  app.post("/api/courses", async (c) => {
    return await coursesApi.create(c.req.raw);
  });

  app.get("/api/courses", async (c) => {
    return await coursesApi.findAll();
  });

  app.get("/api/courses/:id", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await coursesApi.findById(c.req.raw, id);
  });

  app.put("/api/courses/:id", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await coursesApi.update(c.req.raw, id);
  });

  app.delete("/api/courses/:id", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await coursesApi.delete(id);
  });

  app.put("/api/courses/:id/holes", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await coursesApi.updateHoles(c.req.raw, id);
  });

  // Team routes
  app.post("/api/teams", async (c) => {
    return await teamsApi.create(c.req.raw);
  });

  app.get("/api/teams", async (c) => {
    return await teamsApi.findAll();
  });

  app.get("/api/teams/:id", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await teamsApi.findById(c.req.raw, id);
  });

  app.put("/api/teams/:id", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await teamsApi.update(c.req.raw, id);
  });

  // Competition routes
  app.post("/api/competitions", async (c) => {
    return await competitionsApi.create(c.req.raw);
  });

  app.get("/api/competitions", async (c) => {
    return await competitionsApi.findAll();
  });

  app.get("/api/competitions/:id", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await competitionsApi.findById(c.req.raw, id);
  });

  app.put("/api/competitions/:id", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await competitionsApi.update(c.req.raw, id);
  });

  app.delete("/api/competitions/:id", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await competitionsApi.delete(id);
  });

  app.get("/api/competitions/:competitionId/participants", async (c) => {
    const competitionId = parseInt(c.req.param("competitionId"));
    return await participantsApi.findAllForCompetition(competitionId);
  });

  app.get("/api/competitions/:competitionId/leaderboard", async (c) => {
    const competitionId = parseInt(c.req.param("competitionId"));
    return await competitionsApi.getLeaderboard(competitionId);
  });

  // TeeTime routes
  app.post("/api/competitions/:competitionId/tee-times", async (c) => {
    const competitionId = parseInt(c.req.param("competitionId"));
    return await teeTimesApi.createForCompetition(c.req.raw, competitionId);
  });

  app.get("/api/competitions/:competitionId/tee-times", async (c) => {
    const competitionId = parseInt(c.req.param("competitionId"));
    return await teeTimesApi.findAllForCompetition(competitionId);
  });

  app.get("/api/tee-times/:id", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await teeTimesApi.findByIdWithParticipants(c.req.raw, id);
  });

  app.delete("/api/tee-times/:id", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await teeTimesApi.delete(id);
  });

  app.put("/api/tee-times/:id/participants/order", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await teeTimesApi.updateParticipantsOrder(c.req.raw, id);
  });

  // Participant routes
  app.post("/api/participants", async (c) => {
    return await participantsApi.create(c.req.raw);
  });

  app.get("/api/participants", async (c) => {
    return await participantsApi.findAll();
  });

  app.get("/api/participants/:id", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await participantsApi.findById(c.req.raw, id);
  });

  app.put("/api/participants/:id", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await participantsApi.update(c.req.raw, id);
  });

  app.delete("/api/participants/:id", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await participantsApi.delete(id);
  });

  app.put("/api/participants/:id/score", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await participantsApi.updateScore(c.req.raw, id);
  });

  // Series routes
  app.post("/api/series", async (c) => {
    return await seriesApi.create(c.req.raw);
  });

  app.get("/api/series", async (c) => {
    return await seriesApi.findAll();
  });

  app.get("/api/series/public", async (c) => {
    return await seriesApi.findPublic();
  });

  app.get("/api/series/:id", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await seriesApi.findById(c.req.raw, id);
  });

  app.put("/api/series/:id", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await seriesApi.update(c.req.raw, id);
  });

  app.delete("/api/series/:id", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await seriesApi.delete(id);
  });

  app.get("/api/series/:id/competitions", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await seriesApi.getCompetitions(id);
  });

  app.get("/api/series/:id/teams", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await seriesApi.getTeams(id);
  });

  app.get("/api/series/:id/standings", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await seriesApi.getStandings(id);
  });

  app.post("/api/series/:id/teams/:teamId", async (c) => {
    const seriesId = parseInt(c.req.param("id"));
    const teamId = parseInt(c.req.param("teamId"));
    return await seriesApi.addTeam(seriesId, teamId);
  });

  app.delete("/api/series/:id/teams/:teamId", async (c) => {
    const seriesId = parseInt(c.req.param("id"));
    const teamId = parseInt(c.req.param("teamId"));
    return await seriesApi.removeTeam(seriesId, teamId);
  });

  app.get("/api/series/:id/available-teams", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await seriesApi.getAvailableTeams(id);
  });

  // Document routes
  app.post("/api/documents", async (c) => {
    return await documentsApi.create(c.req.raw);
  });

  app.get("/api/documents", async (c) => {
    return await documentsApi.findAll();
  });

  app.get("/api/documents/:id", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await documentsApi.findById(c.req.raw, id);
  });

  app.put("/api/documents/:id", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await documentsApi.update(c.req.raw, id);
  });

  app.delete("/api/documents/:id", async (c) => {
    const id = parseInt(c.req.param("id"));
    return await documentsApi.delete(id);
  });

  app.post("/api/series/:seriesId/documents", async (c) => {
    const seriesId = parseInt(c.req.param("seriesId"));
    return await documentsApi.createForSeries(c.req.raw, seriesId);
  });

  app.get("/api/series/:seriesId/documents", async (c) => {
    const seriesId = parseInt(c.req.param("seriesId"));
    return await documentsApi.findBySeriesId(seriesId);
  });

  app.put("/api/series/:seriesId/documents/:documentId", async (c) => {
    const seriesId = parseInt(c.req.param("seriesId"));
    const documentId = parseInt(c.req.param("documentId"));
    return await documentsApi.updateForSeries(c.req.raw, seriesId, documentId);
  });

  app.delete("/api/series/:seriesId/documents/:documentId", async (c) => {
    const seriesId = parseInt(c.req.param("seriesId"));
    const documentId = parseInt(c.req.param("documentId"));
    return await documentsApi.deleteForSeries(seriesId, documentId);
  });

  app.get("/api/series/:seriesId/documents/types", async (c) => {
    const seriesId = parseInt(c.req.param("seriesId"));
    return await documentsApi.getDocumentTypes(seriesId);
  });

  app.get("/api/series/:seriesId/documents/type/:type", async (c) => {
    const seriesId = parseInt(c.req.param("seriesId"));
    const type = c.req.param("type");
    return await documentsApi.findBySeriesIdAndType(seriesId, type);
  });

  // Static file serving - fallback for frontend
  app.get("*", async (c) => {
    const pathname = new URL(c.req.url).pathname;
    console.log("Serving static file for:", pathname);

    try {
      let filePath = pathname === "/" ? "/index.html" : pathname;
      const fullPath = `frontend_dist${filePath}`;

      const file = Bun.file(fullPath);
      if (file.size > 0 || filePath === "/index.html") {
        const mimeType = filePath.endsWith(".js")
          ? "application/javascript"
          : filePath.endsWith(".css")
          ? "text/css"
          : filePath.endsWith(".html")
          ? "text/html"
          : filePath.endsWith(".png")
          ? "image/png"
          : filePath.endsWith(".jpg") || filePath.endsWith(".jpeg")
          ? "image/jpeg"
          : filePath.endsWith(".svg")
          ? "image/svg+xml"
          : "text/plain";

        return new Response(file, {
          headers: { "Content-Type": mimeType },
        });
      }
    } catch (error) {
      console.log("File not found:", error);
    }

    // For SPA routes, serve index.html
    try {
      const indexFile = Bun.file("frontend_dist/index.html");
      return new Response(indexFile, {
        headers: { "Content-Type": "text/html" },
      });
    } catch (error) {
      return c.text("Not Found", 404);
    }
  });

  return app;
}

```

# src/database/db.ts

```ts
import { Database } from "bun:sqlite";
import { InitialSchemaMigration } from "./migrations/001_initial_schema";
import { AddTeeTimeIdMigration } from "./migrations/002_add_tee_time_id";
import { AddParticipantScoreMigration } from "./migrations/003_add_participant_score";
import { AddSeriesMigration } from "./migrations/004_add_series";
import { AddSeriesFieldsMigration } from "./migrations/005_add_series_fields";
import { SeriesTeamsJunctionMigration } from "./migrations/006_series_teams_junction";
import { AddDocumentsMigration } from "./migrations/007_add_documents";
import { AddLandingDocumentToSeriesMigration } from "./migrations/008_add_landing_document_to_series";

export function createDatabase(dbPath: string = "golf_series.db"): Database {
  const db = new Database(dbPath);

  // Enable foreign keys
  db.run("PRAGMA foreign_keys = ON");

  return db;
}

export async function initializeDatabase(db: Database): Promise<void> {
  // Create migrations table if it doesn't exist
  db.run(`
    CREATE TABLE IF NOT EXISTS migrations (
      version INTEGER PRIMARY KEY,
      description TEXT NOT NULL,
      applied_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `);

  // Get applied migrations
  const appliedMigrations = db
    .query("SELECT version FROM migrations")
    .all() as { version: number }[];
  const appliedVersions = new Set(appliedMigrations.map((m) => m.version));

  // Define migrations in order
  const migrations = [
    new InitialSchemaMigration(db),
    new AddTeeTimeIdMigration(db),
    new AddParticipantScoreMigration(db),
    new AddSeriesMigration(db),
    new AddSeriesFieldsMigration(db),
    new SeriesTeamsJunctionMigration(db),
    new AddDocumentsMigration(db),
    new AddLandingDocumentToSeriesMigration(db),
  ];

  // Apply pending migrations
  for (const migration of migrations) {
    if (!appliedVersions.has(migration.version)) {
      await migration.up();
      db.run("INSERT INTO migrations (version, description) VALUES (?, ?)", [
        migration.version,
        migration.description,
      ]);
    }
  }
}

export async function createTestDatabase(): Promise<Database> {
  const db = createDatabase(":memory:");
  await initializeDatabase(db);
  return db;
}

```

# src/database/migrate.ts

```ts
import { createDatabase, initializeDatabase } from "./db";

async function migrate() {
  const db = createDatabase();
  await initializeDatabase(db);
  console.log("Database initialized successfully!");
  db.close();
}

migrate().catch(console.error);

```

# src/database/migrations/001_initial_schema.ts

```ts
import { Migration } from "./base";

export class InitialSchemaMigration extends Migration {
  version = 1;
  description = "Initial database schema";

  async up(): Promise<void> {
    // Create courses table
    await this.execute(`
      CREATE TABLE IF NOT EXISTS courses (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        pars TEXT NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Create teams table
    await this.execute(`
      CREATE TABLE IF NOT EXISTS teams (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL UNIQUE,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Create competitions table
    await this.execute(`
      CREATE TABLE IF NOT EXISTS competitions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        date TEXT NOT NULL,
        course_id INTEGER NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (course_id) REFERENCES courses(id)
      )
    `);

    // Create tee_times table
    await this.execute(`
      CREATE TABLE IF NOT EXISTS tee_times (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        teetime TEXT NOT NULL,
        competition_id INTEGER NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (competition_id) REFERENCES competitions(id)
      )
    `);

    // Create participants table
    await this.execute(`
      CREATE TABLE IF NOT EXISTS participants (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        tee_order INTEGER NOT NULL,
        team_id INTEGER NOT NULL,
        position_name TEXT NOT NULL,
        player_names TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (team_id) REFERENCES teams(id)
      )
    `);
  }

  async down(): Promise<void> {
    await this.execute("DROP TABLE IF EXISTS participants");
    await this.execute("DROP TABLE IF EXISTS tee_times");
    await this.execute("DROP TABLE IF EXISTS competitions");
    await this.execute("DROP TABLE IF EXISTS teams");
    await this.execute("DROP TABLE IF EXISTS courses");
  }
}

```

# src/database/migrations/002_add_tee_time_id.ts

```ts
import { Migration } from "./base";

export class AddTeeTimeIdMigration extends Migration {
  version = 2;
  description = "Add tee_time_id to participants table";

  async up(): Promise<void> {
    const columnExists = await this.columnExists("participants", "tee_time_id");
    if (!columnExists) {
      await this.execute(`
        ALTER TABLE participants 
        ADD COLUMN tee_time_id INTEGER REFERENCES tee_times(id)
      `);
    }
  }

  async down(): Promise<void> {
    // SQLite doesn't support dropping columns, so we need to recreate the table
    // This is a simplified version that would need to be more robust in production
    await this.execute(`
      CREATE TABLE participants_new (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        tee_order INTEGER NOT NULL,
        team_id INTEGER NOT NULL,
        position_name TEXT NOT NULL,
        player_names TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (team_id) REFERENCES teams(id)
      )
    `);

    await this.execute(`
      INSERT INTO participants_new 
      SELECT id, tee_order, team_id, position_name, player_names, created_at, updated_at 
      FROM participants
    `);

    await this.execute("DROP TABLE participants");
    await this.execute("ALTER TABLE participants_new RENAME TO participants");
  }
}

```

# src/database/migrations/003_add_participant_score.ts

```ts
import { Migration } from "./base";

export class AddParticipantScoreMigration extends Migration {
  version = 3;
  description = "Add score field to participants table";

  async up(): Promise<void> {
    const columnExists = await this.columnExists("participants", "score");
    if (!columnExists) {
      await this.execute(`
        ALTER TABLE participants 
        ADD COLUMN score TEXT DEFAULT '[]'
      `);
    }
  }

  async down(): Promise<void> {
    // SQLite doesn't support dropping columns, so we need to recreate the table
    await this.execute(`
      CREATE TABLE participants_new (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        tee_order INTEGER NOT NULL,
        team_id INTEGER NOT NULL,
        tee_time_id INTEGER NOT NULL,
        position_name TEXT NOT NULL,
        player_names TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (team_id) REFERENCES teams(id),
        FOREIGN KEY (tee_time_id) REFERENCES tee_times(id)
      )
    `);

    await this.execute(`
      INSERT INTO participants_new 
      SELECT id, tee_order, team_id, tee_time_id, position_name, player_names, created_at, updated_at 
      FROM participants
    `);

    await this.execute("DROP TABLE participants");
    await this.execute("ALTER TABLE participants_new RENAME TO participants");
  }
}

```

# src/database/migrations/004_add_series.ts

```ts
import { Migration } from "./base";

export class AddSeriesMigration extends Migration {
  version = 4;
  description = "Add series table and optional series relationships";

  async up(): Promise<void> {
    // Create series table
    await this.execute(`
      CREATE TABLE IF NOT EXISTS series (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL UNIQUE,
        description TEXT,
        banner_image_url TEXT,
        is_public INTEGER DEFAULT 1,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Add optional series_id column to competitions table
    await this.execute(`
      ALTER TABLE competitions 
      ADD COLUMN series_id INTEGER REFERENCES series(id) ON DELETE SET NULL
    `);

    // Add optional series_id column to teams table
    await this.execute(`
      ALTER TABLE teams 
      ADD COLUMN series_id INTEGER REFERENCES series(id) ON DELETE SET NULL
    `);
  }

  async down(): Promise<void> {
    // Remove series_id from teams table
    await this.execute(`
      CREATE TABLE teams_temp (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL UNIQUE,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);
    await this.execute(
      `INSERT INTO teams_temp SELECT id, name, created_at, updated_at FROM teams`
    );
    await this.execute(`DROP TABLE teams`);
    await this.execute(`ALTER TABLE teams_temp RENAME TO teams`);

    // Remove series_id from competitions table
    await this.execute(`
      CREATE TABLE competitions_temp (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        date TEXT NOT NULL,
        course_id INTEGER NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (course_id) REFERENCES courses(id)
      )
    `);
    await this.execute(
      `INSERT INTO competitions_temp SELECT id, name, date, course_id, created_at, updated_at FROM competitions`
    );
    await this.execute(`DROP TABLE competitions`);
    await this.execute(`ALTER TABLE competitions_temp RENAME TO competitions`);

    // Drop series table
    await this.execute("DROP TABLE IF EXISTS series");
  }
}

```

# src/database/migrations/005_add_series_fields.ts

```ts
import { Migration } from "./base";

export class AddSeriesFieldsMigration extends Migration {
  version = 5;
  description = "Add banner_image_url and is_public fields to series table";

  async up(): Promise<void> {
    // Add banner_image_url column if it doesn't exist
    const bannerColumnExists = await this.columnExists("series", "banner_image_url");
    if (!bannerColumnExists) {
      await this.execute(`
        ALTER TABLE series 
        ADD COLUMN banner_image_url TEXT
      `);
    }

    // Add is_public column if it doesn't exist
    const publicColumnExists = await this.columnExists("series", "is_public");
    if (!publicColumnExists) {
      await this.execute(`
        ALTER TABLE series 
        ADD COLUMN is_public INTEGER DEFAULT 1
      `);
    }
  }

  async down(): Promise<void> {
    // SQLite doesn't support dropping columns, so we need to recreate the table
    await this.execute(`
      CREATE TABLE series_new (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL UNIQUE,
        description TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);

    await this.execute(`
      INSERT INTO series_new (id, name, description, created_at, updated_at)
      SELECT id, name, description, created_at, updated_at 
      FROM series
    `);

    await this.execute("DROP TABLE series");
    await this.execute("ALTER TABLE series_new RENAME TO series");
  }
}

```

# src/database/migrations/006_series_teams_junction.ts

```ts
import { Migration } from "./base";

export class SeriesTeamsJunctionMigration extends Migration {
  version = 6;
  description =
    "Create series_teams junction table for many-to-many relationship";

  async up(): Promise<void> {
    // Create series_teams junction table
    await this.execute(`
      CREATE TABLE IF NOT EXISTS series_teams (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        series_id INTEGER NOT NULL,
        team_id INTEGER NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (series_id) REFERENCES series(id) ON DELETE CASCADE,
        FOREIGN KEY (team_id) REFERENCES teams(id) ON DELETE CASCADE,
        UNIQUE(series_id, team_id)
      )
    `);

    // Migrate existing data from teams.series_id to junction table
    await this.execute(`
      INSERT OR IGNORE INTO series_teams (series_id, team_id)
      SELECT series_id, id
      FROM teams
      WHERE series_id IS NOT NULL
    `);

    // Temporarily disable foreign keys for table restructuring
    await this.execute("PRAGMA foreign_keys = OFF");

    // Remove series_id column from teams table
    await this.execute(`DROP TABLE IF EXISTS teams_new`);
    await this.execute(`
      CREATE TABLE teams_new (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL UNIQUE,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);

    await this.execute(`
      INSERT INTO teams_new (id, name, created_at, updated_at)
      SELECT id, name, created_at, updated_at
      FROM teams
    `);

    await this.execute("DROP TABLE teams");
    await this.execute("ALTER TABLE teams_new RENAME TO teams");

    // Re-enable foreign keys
    await this.execute("PRAGMA foreign_keys = ON");
  }

  async down(): Promise<void> {
    // Add series_id back to teams table
    await this.execute(`
      ALTER TABLE teams 
      ADD COLUMN series_id INTEGER REFERENCES series(id) ON DELETE SET NULL
    `);

    // Migrate data back (only first series per team)
    await this.execute(`
      UPDATE teams 
      SET series_id = (
        SELECT series_id 
        FROM series_teams 
        WHERE series_teams.team_id = teams.id 
        LIMIT 1
      )
    `);

    // Drop junction table
    await this.execute("DROP TABLE IF EXISTS series_teams");
  }
}

```

# src/database/migrations/007_add_documents.ts

```ts
import { Migration } from "./base";

export class AddDocumentsMigration extends Migration {
  version = 7;
  description = "Add documents table for series-related documentation";

  async up(): Promise<void> {
    // Create documents table
    await this.execute(`
      CREATE TABLE IF NOT EXISTS documents (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        content TEXT NOT NULL,
        type TEXT NOT NULL,
        series_id INTEGER NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (series_id) REFERENCES series(id) ON DELETE CASCADE
      )
    `);

    // Create index for series_id for better query performance
    await this.execute(`
      CREATE INDEX IF NOT EXISTS idx_documents_series_id ON documents(series_id)
    `);

    // Create index for type for filtering by document type
    await this.execute(`
      CREATE INDEX IF NOT EXISTS idx_documents_type ON documents(type)
    `);
  }

  async down(): Promise<void> {
    // Drop indexes
    await this.execute("DROP INDEX IF EXISTS idx_documents_type");
    await this.execute("DROP INDEX IF EXISTS idx_documents_series_id");

    // Drop documents table
    await this.execute("DROP TABLE IF EXISTS documents");
  }
}

```

# src/database/migrations/008_add_landing_document_to_series.ts

```ts
import { Migration } from "./base";

export class AddLandingDocumentToSeriesMigration extends Migration {
  version = 8;
  description = "Add landing_document_id field to series table";

  async up(): Promise<void> {
    // Add landing_document_id column to series table
    await this.execute(`
      ALTER TABLE series 
      ADD COLUMN landing_document_id INTEGER REFERENCES documents(id) ON DELETE SET NULL
    `);

    // Create index for landing_document_id for better query performance
    await this.execute(`
      CREATE INDEX IF NOT EXISTS idx_series_landing_document_id ON series(landing_document_id)
    `);
  }

  async down(): Promise<void> {
    // Drop index
    await this.execute("DROP INDEX IF EXISTS idx_series_landing_document_id");

    // Remove landing_document_id from series table by recreating without the column
    await this.execute(`
      CREATE TABLE series_temp (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL UNIQUE,
        description TEXT,
        banner_image_url TEXT,
        is_public INTEGER DEFAULT 1,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);

    await this.execute(`
      INSERT INTO series_temp (id, name, description, banner_image_url, is_public, created_at, updated_at)
      SELECT id, name, description, banner_image_url, is_public, created_at, updated_at FROM series
    `);

    await this.execute(`DROP TABLE series`);
    await this.execute(`ALTER TABLE series_temp RENAME TO series`);
  }
}

```

# src/database/migrations/base.ts

```ts
import { Database } from "bun:sqlite";

export abstract class Migration {
  abstract version: number;
  abstract description: string;

  constructor(protected db: Database) {}

  abstract up(): Promise<void>;
  abstract down(): Promise<void>;

  protected async execute(sql: string): Promise<void> {
    this.db.run(sql);
  }

  protected async columnExists(
    table: string,
    column: string
  ): Promise<boolean> {
    const stmt = this.db.prepare(
      `SELECT name FROM pragma_table_info(?) WHERE name = ?`
    );
    const result = stmt.get(table, column);
    return result !== null;
  }
}

```

# src/index.ts

```ts
import "./server";

console.log("Hello via Bun!");

```

# src/server.ts

```ts
import { createApp } from "./app";
import { createDatabase, initializeDatabase } from "./database/db";

const db = createDatabase();
initializeDatabase(db);
const app = createApp(db);

const server = Bun.serve({
  port: process.env.PORT || 3010,
  fetch: app.fetch,
});

console.log(`Server running on port ${server.port}`);

```

# src/services/competition-service.ts

```ts
import { Database } from "bun:sqlite";
import type {
  Competition,
  CreateCompetitionDto,
  LeaderboardEntry,
  Participant,
  UpdateCompetitionDto,
} from "../types";

function isValidYYYYMMDD(date: string): boolean {
  const parsed = Date.parse(date);
  return !isNaN(parsed) && /^\d{4}-\d{2}-\d{2}$/.test(date);
}

export class CompetitionService {
  constructor(private db: Database) {}

  async create(data: CreateCompetitionDto): Promise<Competition> {
    if (!data.name?.trim()) {
      throw new Error("Competition name is required");
    }

    if (!data.date?.trim()) {
      throw new Error("Competition date is required");
    }

    // Validate YYYY-MM-DD format
    if (!isValidYYYYMMDD(data.date)) {
      throw new Error("Date must be in YYYY-MM-DD format (e.g., 2024-03-21)");
    }

    // Verify course exists
    const courseStmt = this.db.prepare("SELECT id FROM courses WHERE id = ?");
    const course = courseStmt.get(data.course_id);
    if (!course) {
      throw new Error("Course not found");
    }

    // Verify series exists if provided
    if (data.series_id) {
      const seriesStmt = this.db.prepare("SELECT id FROM series WHERE id = ?");
      const series = seriesStmt.get(data.series_id);
      if (!series) {
        throw new Error("Series not found");
      }
    }

    const stmt = this.db.prepare(`
      INSERT INTO competitions (name, date, course_id, series_id)
      VALUES (?, ?, ?, ?)
      RETURNING *
    `);

    return stmt.get(
      data.name,
      data.date,
      data.course_id,
      data.series_id || null
    ) as Competition;
  }

  async findAll(): Promise<
    (Competition & {
      course: { id: number; name: string };
      participant_count: number;
    })[]
  > {
    const stmt = this.db.prepare(`
      SELECT c.*, co.name as course_name,
        (SELECT COUNT(*) 
         FROM participants p 
         JOIN tee_times t ON p.tee_time_id = t.id 
         WHERE t.competition_id = c.id) as participant_count
      FROM competitions c
      JOIN courses co ON c.course_id = co.id
    `);
    return stmt.all().map((row: any) => ({
      ...row,
      course: {
        id: row.course_id,
        name: row.course_name,
      },
      participant_count: row.participant_count,
    }));
  }

  async findById(
    id: number
  ): Promise<(Competition & { course: { id: number; name: string } }) | null> {
    const stmt = this.db.prepare(`
      SELECT c.*, co.name as course_name
      FROM competitions c
      JOIN courses co ON c.course_id = co.id
      WHERE c.id = ?
    `);
    const row = stmt.get(id) as any;

    if (!row) return null;

    return {
      ...row,
      course: {
        id: row.course_id,
        name: row.course_name,
      },
    };
  }

  async update(id: number, data: UpdateCompetitionDto): Promise<Competition> {
    const competition = await this.findById(id);
    if (!competition) {
      throw new Error("Competition not found");
    }

    if (data.name && !data.name.trim()) {
      throw new Error("Competition name cannot be empty");
    }

    if (data.date && !isValidYYYYMMDD(data.date)) {
      throw new Error("Date must be in YYYY-MM-DD format (e.g., 2024-03-21)");
    }

    if (data.course_id) {
      const courseStmt = this.db.prepare("SELECT id FROM courses WHERE id = ?");
      const course = courseStmt.get(data.course_id);
      if (!course) {
        throw new Error("Course not found");
      }
    }

    if (data.series_id !== undefined) {
      if (data.series_id === null) {
        // Allow setting series_id to null
      } else {
        const seriesStmt = this.db.prepare(
          "SELECT id FROM series WHERE id = ?"
        );
        const series = seriesStmt.get(data.series_id);
        if (!series) {
          throw new Error("Series not found");
        }
      }
    }

    const updates: string[] = [];
    const values: any[] = [];

    if (data.name) {
      updates.push("name = ?");
      values.push(data.name);
    }

    if (data.date) {
      updates.push("date = ?");
      values.push(data.date);
    }

    if (data.course_id) {
      updates.push("course_id = ?");
      values.push(data.course_id);
    }

    if (data.series_id !== undefined) {
      updates.push("series_id = ?");
      values.push(data.series_id);
    }

    if (updates.length === 0) {
      return competition;
    }

    updates.push("updated_at = CURRENT_TIMESTAMP");
    values.push(id);

    const stmt = this.db.prepare(`
      UPDATE competitions 
      SET ${updates.join(", ")}
      WHERE id = ?
      RETURNING *
    `);

    return stmt.get(...values) as Competition;
  }

  async delete(id: number): Promise<void> {
    const competition = await this.findById(id);
    if (!competition) {
      throw new Error("Competition not found");
    }

    // Check if competition has any tee times
    const teeTimesStmt = this.db.prepare(
      "SELECT id FROM tee_times WHERE competition_id = ?"
    );
    const teeTimes = teeTimesStmt.all(id);
    if (teeTimes.length > 0) {
      throw new Error("Cannot delete competition that has tee times");
    }

    const stmt = this.db.prepare("DELETE FROM competitions WHERE id = ?");
    stmt.run(id);
  }

  async getLeaderboard(competitionId: number): Promise<LeaderboardEntry[]> {
    // Verify competition exists and get course info
    const competitionStmt = this.db.prepare(`
      SELECT c.*, co.pars
      FROM competitions c
      JOIN courses co ON c.course_id = co.id
      WHERE c.id = ?
    `);
    const competition = competitionStmt.get(competitionId) as
      | (Competition & { pars: string })
      | null;
    if (!competition) {
      throw new Error("Competition not found");
    }
    console.log("competition leaderboard 1");
    // Get all participants for this competition
    const participantsStmt = this.db.prepare(`
      SELECT p.*, tm.name as team_name
      FROM participants p
      JOIN tee_times t ON p.tee_time_id = t.id
      JOIN teams tm ON p.team_id = tm.id
      WHERE t.competition_id = ?
      ORDER BY t.teetime, p.tee_order
    `);
    const participants = participantsStmt.all(competitionId) as (Participant & {
      team_name: string;
    })[];
    // Parse course pars
    const coursePars = JSON.parse(competition.pars);
    if (!coursePars || coursePars.length === 0) {
      throw new Error("Invalid course pars data structure, no pars found");
    }
    const pars = coursePars;
    // Calculate leaderboard entries
    const leaderboard: LeaderboardEntry[] = participants.map((participant) => {
      // Parse the score field
      const score =
        typeof participant.score === "string"
          ? JSON.parse(participant.score)
          : Array.isArray(participant.score)
          ? participant.score
          : [];

      // Count holes played: positive scores and -1 (gave up) count as played
      // 0 means unreported/cleared, so it doesn't count as played
      const holesPlayed = score.filter((s: number) => s > 0 || s === -1).length;

      // Calculate total shots: only count positive scores
      // -1 (gave up) and 0 (unreported) don't count towards total
      const totalShots = score.reduce(
        (sum: number, shots: number) => sum + (shots > 0 ? shots : 0),
        0
      );

      // Calculate relative to par: only count positive scores
      let relativeToPar = 0;
      try {
        for (let i = 0; i < score.length; i++) {
          if (score[i] > 0 && pars[i] !== undefined) {
            relativeToPar += score[i] - pars[i];
          }
          // Note: -1 (gave up) and 0 (unreported) don't contribute to par calculation
        }
      } catch (error) {
        console.error("Error calculating relative to par", error);
        throw error;
      }

      return {
        participant: {
          ...participant,
          score,
        },
        totalShots,
        holesPlayed,
        relativeToPar,
      };
    });
    // Sort by relative to par (ascending)
    return leaderboard.sort((a, b) => a.relativeToPar - b.relativeToPar);
  }
}

```

# src/services/course-service.ts

```ts
import { Database } from "bun:sqlite";
import type { Course, CreateCourseDto, UpdateCourseDto } from "../types";

interface ParsData {
  holes: number[];
  out: number;
  in: number;
  total: number;
}

function calculatePars(pars: number[]): ParsData {
  const holes = pars;
  const out = pars.slice(0, 9).reduce((sum, par) => sum + par, 0);
  const in_ = pars.slice(9).reduce((sum, par) => sum + par, 0);
  const total = out + in_;

  return {
    holes,
    out,
    in: in_,
    total,
  };
}

export class CourseService {
  constructor(private db: Database) {}

  async create(data: CreateCourseDto): Promise<Course> {
    if (!data.name?.trim()) {
      throw new Error("Course name is required");
    }

    const stmt = this.db.prepare(`
      INSERT INTO courses (name, pars)
      VALUES (?, ?)
      RETURNING *
    `);

    const course = stmt.get(data.name, JSON.stringify([])) as Course;
    const pars = JSON.parse(course.pars as unknown as string);
    course.pars = calculatePars(pars);
    return course;
  }

  async findAll(): Promise<Course[]> {
    const stmt = this.db.prepare("SELECT * FROM courses");
    const courses = stmt.all() as Course[];
    return courses.map((course) => ({
      ...course,
      pars: calculatePars(JSON.parse(course.pars as unknown as string)),
    }));
  }

  async findById(id: number): Promise<Course | null> {
    const stmt = this.db.prepare("SELECT * FROM courses WHERE id = ?");
    const course = stmt.get(id) as Course | null;

    if (!course) return null;

    const pars = JSON.parse(course.pars as unknown as string);
    return {
      ...course,
      pars: calculatePars(pars),
    };
  }

  async update(id: number, data: UpdateCourseDto): Promise<Course> {
    const course = await this.findById(id);
    if (!course) {
      throw new Error("Course not found");
    }

    if (data.name && !data.name.trim()) {
      throw new Error("Course name cannot be empty");
    }

    const updates: string[] = [];
    const values: any[] = [];

    if (data.name) {
      updates.push("name = ?");
      values.push(data.name);
    }

    if (updates.length === 0) {
      return course;
    }

    updates.push("updated_at = CURRENT_TIMESTAMP");
    values.push(id);

    const stmt = this.db.prepare(`
      UPDATE courses 
      SET ${updates.join(", ")}
      WHERE id = ?
      RETURNING *
    `);

    const updated = stmt.get(...values) as Course;
    const pars = JSON.parse(updated.pars as unknown as string);
    return {
      ...updated,
      pars: calculatePars(pars),
    };
  }

  async updateHoles(id: number, pars: number[]): Promise<Course> {
    const course = await this.findById(id);
    if (!course) {
      throw new Error("Course not found");
    }

    if (pars.length > 18) {
      throw new Error("Course cannot have more than 18 holes");
    }

    if (!pars.every((par) => Number.isInteger(par) && par >= 3 && par <= 6)) {
      throw new Error("All pars must be integers between 3 and 6");
    }

    const stmt = this.db.prepare(`
      UPDATE courses 
      SET pars = ?, updated_at = CURRENT_TIMESTAMP
      WHERE id = ?
      RETURNING *
    `);

    const updated = stmt.get(JSON.stringify(pars), id) as Course;
    return {
      ...updated,
      pars: calculatePars(pars),
    };
  }

  async delete(id: number): Promise<void> {
    const course = await this.findById(id);
    if (!course) {
      throw new Error("Course not found");
    }

    // Check if course is used in any competitions
    const competitionsStmt = this.db.prepare(
      "SELECT id FROM competitions WHERE course_id = ?"
    );
    const competitions = competitionsStmt.all(id);
    if (competitions.length > 0) {
      throw new Error("Cannot delete course that is used in competitions");
    }

    const stmt = this.db.prepare("DELETE FROM courses WHERE id = ?");
    stmt.run(id);
  }
}

```

# src/services/document-service.ts

```ts
import { Database } from "bun:sqlite";
import type { CreateDocumentDto, Document, UpdateDocumentDto } from "../types";

export class DocumentService {
  constructor(private db: Database) {}

  async create(data: CreateDocumentDto): Promise<Document> {
    if (!data.title?.trim()) {
      throw new Error("Document title is required");
    }
    if (!data.content?.trim()) {
      throw new Error("Document content is required");
    }
    if (!data.type?.trim()) {
      throw new Error("Document type is required");
    }
    if (!data.series_id) {
      throw new Error("Series ID is required");
    }

    // Verify series exists
    const seriesStmt = this.db.prepare("SELECT id FROM series WHERE id = ?");
    const series = seriesStmt.get(data.series_id);
    if (!series) {
      throw new Error("Series not found");
    }

    try {
      const stmt = this.db.prepare(`
        INSERT INTO documents (title, content, type, series_id, created_at, updated_at)
        VALUES (?, ?, ?, ?, strftime('%Y-%m-%d %H:%M:%S.%f', 'now'), strftime('%Y-%m-%d %H:%M:%S.%f', 'now'))
        RETURNING *
      `);

      const result = stmt.get(
        data.title.trim(),
        data.content.trim(),
        data.type.trim(),
        data.series_id
      ) as Document;

      return result;
    } catch (error) {
      throw error;
    }
  }

  async findAll(): Promise<Document[]> {
    const stmt = this.db.prepare(`
      SELECT id, title, content, type, series_id, created_at, updated_at
      FROM documents
      ORDER BY strftime('%s.%f', created_at) DESC
    `);
    return stmt.all() as Document[];
  }

  async findById(id: number): Promise<Document | null> {
    const stmt = this.db.prepare(`
      SELECT id, title, content, type, series_id, created_at, updated_at
      FROM documents
      WHERE id = ?
    `);
    const result = stmt.get(id) as Document | undefined;
    return result || null;
  }

  async findBySeriesId(seriesId: number): Promise<Document[]> {
    // Verify series exists
    const seriesStmt = this.db.prepare("SELECT id FROM series WHERE id = ?");
    const series = seriesStmt.get(seriesId);
    if (!series) {
      throw new Error("Series not found");
    }

    const stmt = this.db.prepare(`
      SELECT id, title, content, type, series_id, created_at, updated_at
      FROM documents
      WHERE series_id = ?
      ORDER BY type, title
    `);
    return stmt.all(seriesId) as Document[];
  }

  async findBySeriesIdAndType(
    seriesId: number,
    type: string
  ): Promise<Document[]> {
    // Verify series exists
    const seriesStmt = this.db.prepare("SELECT id FROM series WHERE id = ?");
    const series = seriesStmt.get(seriesId);
    if (!series) {
      throw new Error("Series not found");
    }

    const stmt = this.db.prepare(`
      SELECT id, title, content, type, series_id, created_at, updated_at
      FROM documents
      WHERE series_id = ? AND type = ?
      ORDER BY title
    `);
    return stmt.all(seriesId, type.trim()) as Document[];
  }

  async update(id: number, data: UpdateDocumentDto): Promise<Document> {
    const document = await this.findById(id);
    if (!document) {
      throw new Error("Document not found");
    }

    if (data.title !== undefined && !data.title.trim()) {
      throw new Error("Document title cannot be empty");
    }
    if (data.content !== undefined && !data.content.trim()) {
      throw new Error("Document content cannot be empty");
    }
    if (data.type !== undefined && !data.type.trim()) {
      throw new Error("Document type cannot be empty");
    }

    const updates: string[] = [];
    const values: any[] = [];

    if (data.title !== undefined) {
      updates.push("title = ?");
      values.push(data.title.trim());
    }

    if (data.content !== undefined) {
      updates.push("content = ?");
      values.push(data.content.trim());
    }

    if (data.type !== undefined) {
      updates.push("type = ?");
      values.push(data.type.trim());
    }

    if (updates.length === 0) {
      return document;
    }

    updates.push("updated_at = strftime('%Y-%m-%d %H:%M:%S.%f', 'now')");
    values.push(id);

    try {
      const stmt = this.db.prepare(`
        UPDATE documents
        SET ${updates.join(", ")}
        WHERE id = ?
        RETURNING *
      `);

      const result = stmt.get(...values) as Document;
      return result;
    } catch (error) {
      throw error;
    }
  }

  async delete(id: number): Promise<void> {
    const document = await this.findById(id);
    if (!document) {
      throw new Error("Document not found");
    }

    const stmt = this.db.prepare("DELETE FROM documents WHERE id = ?");
    stmt.run(id);
  }

  async getDocumentTypes(seriesId: number): Promise<string[]> {
    // Verify series exists
    const seriesStmt = this.db.prepare("SELECT id FROM series WHERE id = ?");
    const series = seriesStmt.get(seriesId);
    if (!series) {
      throw new Error("Series not found");
    }

    const stmt = this.db.prepare(`
      SELECT DISTINCT type
      FROM documents
      WHERE series_id = ?
      ORDER BY type
    `);
    const results = stmt.all(seriesId) as { type: string }[];
    return results.map((r) => r.type);
  }
}

```

# src/services/participant-service.ts

```ts
import { Database } from "bun:sqlite";
import type {
  CreateParticipantDto,
  Participant,
  UpdateParticipantDto,
} from "../types";

export class ParticipantService {
  constructor(private db: Database) {}

  async create(data: CreateParticipantDto): Promise<Participant> {
    if (!data.position_name?.trim()) {
      throw new Error("Position name is required");
    }

    if (data.tee_order < 1) {
      throw new Error("Tee order must be greater than 0");
    }

    // Verify team exists
    const teamStmt = this.db.prepare("SELECT id FROM teams WHERE id = ?");
    const team = teamStmt.get(data.team_id);
    if (!team) {
      throw new Error("Team not found");
    }

    // Verify tee time exists
    const teeTimeStmt = this.db.prepare(
      "SELECT id FROM tee_times WHERE id = ?"
    );
    const teeTime = teeTimeStmt.get(data.tee_time_id);
    if (!teeTime) {
      throw new Error("Tee time not found");
    }

    const stmt = this.db.prepare(`
      INSERT INTO participants (tee_order, team_id, tee_time_id, position_name, player_names, score)
      VALUES (?, ?, ?, ?, ?, ?)
      RETURNING *
    `);

    const participant = stmt.get(
      data.tee_order,
      data.team_id,
      data.tee_time_id,
      data.position_name,
      data.player_names || null,
      JSON.stringify([])
    ) as Participant;

    return {
      ...participant,
      score: JSON.parse(participant.score as unknown as string),
    };
  }

  async findAll(): Promise<Participant[]> {
    const stmt = this.db.prepare("SELECT * FROM participants");
    const participants = stmt.all() as Participant[];
    return participants.map((p) => ({
      ...p,
      score: JSON.parse(p.score as unknown as string),
    }));
  }

  async findById(id: number): Promise<Participant | null> {
    const stmt = this.db.prepare("SELECT * FROM participants WHERE id = ?");
    const participant = stmt.get(id) as Participant | null;
    if (!participant) return null;

    let score: any[] = [];
    try {
      score = participant.score
        ? JSON.parse(participant.score as unknown as string)
        : [];
    } catch (e) {
      score = [];
    }

    return {
      ...participant,
      score,
    };
  }

  async update(id: number, data: UpdateParticipantDto): Promise<Participant> {
    const participant = await this.findById(id);
    if (!participant) {
      throw new Error("Participant not found");
    }

    if (data.position_name && !data.position_name.trim()) {
      throw new Error("Position name cannot be empty");
    }

    if (data.tee_order && data.tee_order < 1) {
      throw new Error("Tee order must be greater than 0");
    }

    if (data.team_id) {
      const teamStmt = this.db.prepare("SELECT id FROM teams WHERE id = ?");
      const team = teamStmt.get(data.team_id);
      if (!team) {
        throw new Error("Team not found");
      }
    }

    if (data.tee_time_id) {
      const teeTimeStmt = this.db.prepare(
        "SELECT id FROM tee_times WHERE id = ?"
      );
      const teeTime = teeTimeStmt.get(data.tee_time_id);
      if (!teeTime) {
        throw new Error("Tee time not found");
      }
    }

    const updates: string[] = [];
    const values: any[] = [];

    if (data.tee_order) {
      updates.push("tee_order = ?");
      values.push(data.tee_order);
    }

    if (data.team_id) {
      updates.push("team_id = ?");
      values.push(data.team_id);
    }

    if (data.tee_time_id) {
      updates.push("tee_time_id = ?");
      values.push(data.tee_time_id);
    }

    if (data.position_name) {
      updates.push("position_name = ?");
      values.push(data.position_name);
    }

    if (data.player_names !== undefined) {
      updates.push("player_names = ?");
      values.push(data.player_names);
    }

    if (updates.length === 0) {
      return participant;
    }

    updates.push("updated_at = CURRENT_TIMESTAMP");
    values.push(id);

    const stmt = this.db.prepare(`
      UPDATE participants 
      SET ${updates.join(", ")}
      WHERE id = ?
      RETURNING *
    `);

    const updated = stmt.get(...values) as Participant;
    return {
      ...updated,
      score: JSON.parse(updated.score as unknown as string),
    };
  }

  async findAllForCompetition(competitionId: number): Promise<Participant[]> {
    // Verify competition exists
    const competitionStmt = this.db.prepare(
      "SELECT id FROM competitions WHERE id = ?"
    );
    const competition = competitionStmt.get(competitionId);
    if (!competition) {
      throw new Error("Competition not found");
    }

    // Join with tee_times to get participants for this competition
    const stmt = this.db.prepare(`
      SELECT p.* 
      FROM participants p
      JOIN tee_times t ON p.tee_time_id = t.id
      WHERE t.competition_id = ?
      ORDER BY t.teetime, p.tee_order
    `);
    const participants = stmt.all(competitionId) as Participant[];
    return participants.map((p) => ({
      ...p,
      score: JSON.parse(p.score as unknown as string),
    }));
  }

  async updateScore(
    id: number,
    hole: number,
    shots: number
  ): Promise<Participant> {
    const participant = await this.findById(id);
    if (!participant) {
      throw new Error("Participant not found");
    }

    // Get the course to validate hole number
    const courseStmt = this.db.prepare(`
      SELECT co.pars
      FROM participants p
      JOIN tee_times t ON p.tee_time_id = t.id
      JOIN competitions c ON t.competition_id = c.id
      JOIN courses co ON c.course_id = co.id
      WHERE p.id = ?
    `);
    const course = courseStmt.get(id) as { pars: string } | null;
    if (!course) {
      throw new Error("Could not find course for participant");
    }

    const pars = JSON.parse(course.pars);
    if (hole < 1 || hole > pars.length) {
      throw new Error(`Hole number must be between 1 and ${pars.length}`);
    }

    // Allow -1 (gave up) and 0 (unreported/cleared score) as special values
    // Regular shots must be positive
    if (shots !== -1 && shots !== 0 && shots < 1) {
      throw new Error(
        "Shots must be greater than 0, or -1 (gave up), or 0 (clear score)"
      );
    }

    // Initialize score array with zeros if null or empty
    let score = participant.score || [];
    if (!Array.isArray(score)) {
      score = new Array(pars.length).fill(0);
    } else {
      for (let i = 0; i < pars.length; i++) {
        if (score[i] === null || score[i] === undefined) {
          score[i] = 0;
        }
      }
    }

    score[hole - 1] = shots;

    const stmt = this.db.prepare(`
      UPDATE participants 
      SET score = ?, updated_at = CURRENT_TIMESTAMP
      WHERE id = ?
      RETURNING *
    `);

    const stringifiedScore = JSON.stringify(score);
    stmt.run(stringifiedScore, id);
    const updated = await this.findById(id);
    if (!updated) {
      throw new Error("Participant not found");
    }
    return updated;
  }

  async delete(id: number): Promise<void> {
    const participant = await this.findById(id);
    if (!participant) {
      throw new Error("Participant not found");
    }

    const stmt = this.db.prepare("DELETE FROM participants WHERE id = ?");
    stmt.run(id);
  }
}

```

# src/services/series-service.ts

```ts
import { Database } from "bun:sqlite";
import type {
  CreateSeriesDto,
  Series,
  SeriesStandings,
  SeriesTeamStanding,
  UpdateSeriesDto,
} from "../types";

export class SeriesService {
  constructor(private db: Database) {}

  async create(data: CreateSeriesDto): Promise<Series> {
    if (!data.name?.trim()) {
      throw new Error("Series name is required");
    }

    try {
      const stmt = this.db.prepare(`
        INSERT INTO series (name, description, banner_image_url, is_public, created_at, updated_at)
        VALUES (?, ?, ?, ?, strftime('%Y-%m-%d %H:%M:%S.%f', 'now'), strftime('%Y-%m-%d %H:%M:%S.%f', 'now'))
        RETURNING *
      `);

      const result = stmt.get(
        data.name,
        data.description || null,
        data.banner_image_url || null,
        data.is_public !== undefined ? (data.is_public ? 1 : 0) : 1
      ) as any;

      // Convert is_public from integer to boolean
      return {
        ...result,
        is_public: Boolean(result.is_public),
      } as Series;
    } catch (error) {
      if (
        error instanceof Error &&
        error.message.includes("UNIQUE constraint failed")
      ) {
        throw new Error("Series name must be unique");
      }
      throw error;
    }
  }

  async findAll(): Promise<Series[]> {
    const stmt = this.db.prepare(`
      SELECT id, name, description, banner_image_url, is_public, landing_document_id, created_at, updated_at
      FROM series
      ORDER BY strftime('%s.%f', created_at) DESC
    `);
    const results = stmt.all() as any[];
    return results.map((result) => ({
      ...result,
      is_public: Boolean(result.is_public),
    })) as Series[];
  }

  async findPublic(): Promise<Series[]> {
    const stmt = this.db.prepare(`
      SELECT id, name, description, banner_image_url, is_public, landing_document_id, created_at, updated_at
      FROM series
      WHERE is_public = 1
      ORDER BY strftime('%s.%f', created_at) DESC
    `);
    const results = stmt.all() as any[];
    return results.map((result) => ({
      ...result,
      is_public: Boolean(result.is_public),
    })) as Series[];
  }

  async findById(id: number): Promise<Series | null> {
    const stmt = this.db.prepare(`
      SELECT id, name, description, banner_image_url, is_public, landing_document_id, created_at, updated_at
      FROM series
      WHERE id = ?
    `);
    const result = stmt.get(id) as any;
    if (!result) return null;

    return {
      ...result,
      is_public: Boolean(result.is_public),
    } as Series;
  }

  async update(id: number, data: UpdateSeriesDto): Promise<Series> {
    const series = await this.findById(id);
    if (!series) {
      throw new Error("Series not found");
    }

    if (data.name !== undefined && !data.name.trim()) {
      throw new Error("Series name cannot be empty");
    }

    // Validate landing_document_id if provided
    if (data.landing_document_id !== undefined) {
      if (data.landing_document_id !== null) {
        const documentStmt = this.db.prepare(`
          SELECT id, series_id FROM documents WHERE id = ?
        `);
        const document = documentStmt.get(data.landing_document_id) as any;

        if (!document) {
          throw new Error("Landing document not found");
        }

        if (document.series_id !== id) {
          throw new Error("Landing document must belong to the same series");
        }
      }
    }

    const updates: string[] = [];
    const values: any[] = [];

    if (data.name !== undefined) {
      updates.push("name = ?");
      values.push(data.name);
    }

    if (data.description !== undefined) {
      updates.push("description = ?");
      values.push(data.description);
    }

    if (data.banner_image_url !== undefined) {
      updates.push("banner_image_url = ?");
      values.push(data.banner_image_url);
    }

    if (data.is_public !== undefined) {
      updates.push("is_public = ?");
      values.push(data.is_public ? 1 : 0);
    }

    if (data.landing_document_id !== undefined) {
      updates.push("landing_document_id = ?");
      values.push(data.landing_document_id);
    }

    if (updates.length === 0) {
      return series;
    }

    updates.push("updated_at = strftime('%Y-%m-%d %H:%M:%S.%f', 'now')");
    values.push(id);

    try {
      const stmt = this.db.prepare(`
        UPDATE series
        SET ${updates.join(", ")}
        WHERE id = ?
        RETURNING *
      `);

      const result = stmt.get(...values) as any;
      return {
        ...result,
        is_public: Boolean(result.is_public),
      } as Series;
    } catch (error) {
      if (
        error instanceof Error &&
        error.message.includes("UNIQUE constraint failed")
      ) {
        throw new Error("Series name must be unique");
      }
      throw error;
    }
  }

  async delete(id: number): Promise<void> {
    const series = await this.findById(id);
    if (!series) {
      throw new Error("Series not found");
    }

    const stmt = this.db.prepare("DELETE FROM series WHERE id = ?");
    stmt.run(id);
  }

  async getCompetitions(id: number): Promise<any[]> {
    const series = await this.findById(id);
    if (!series) {
      throw new Error("Series not found");
    }

    const stmt = this.db.prepare(`
      SELECT c.*, co.name as course_name
      FROM competitions c
      JOIN courses co ON c.course_id = co.id
      WHERE c.series_id = ?
      ORDER BY c.date
    `);

    return stmt.all(id).map((row: any) => ({
      ...row,
      course: {
        id: row.course_id,
        name: row.course_name,
      },
    }));
  }

  async getTeams(id: number): Promise<any[]> {
    const series = await this.findById(id);
    if (!series) {
      throw new Error("Series not found");
    }

    const stmt = this.db.prepare(`
      SELECT t.id, t.name, t.created_at, t.updated_at
      FROM teams t
      JOIN series_teams st ON t.id = st.team_id
      WHERE st.series_id = ?
      ORDER BY t.name
    `);

    return stmt.all(id);
  }

  async addTeam(seriesId: number, teamId: number): Promise<void> {
    // Verify series exists
    const series = await this.findById(seriesId);
    if (!series) {
      throw new Error("Series not found");
    }

    // Verify team exists
    const teamStmt = this.db.prepare("SELECT id FROM teams WHERE id = ?");
    const team = teamStmt.get(teamId);
    if (!team) {
      throw new Error("Team not found");
    }

    try {
      const stmt = this.db.prepare(`
        INSERT INTO series_teams (series_id, team_id)
        VALUES (?, ?)
      `);
      stmt.run(seriesId, teamId);
    } catch (error) {
      if (
        error instanceof Error &&
        error.message.includes("UNIQUE constraint failed")
      ) {
        throw new Error("Team is already in this series");
      }
      throw error;
    }
  }

  async removeTeam(seriesId: number, teamId: number): Promise<void> {
    const stmt = this.db.prepare(`
      DELETE FROM series_teams
      WHERE series_id = ? AND team_id = ?
    `);
    const result = stmt.run(seriesId, teamId);

    if (result.changes === 0) {
      throw new Error("Team is not in this series");
    }
  }

  async getAvailableTeams(seriesId: number): Promise<any[]> {
    const stmt = this.db.prepare(`
      SELECT t.id, t.name, t.created_at, t.updated_at
      FROM teams t
      WHERE t.id NOT IN (
        SELECT team_id
        FROM series_teams
        WHERE series_id = ?
      )
      ORDER BY t.name
    `);

    return stmt.all(seriesId);
  }

  async getStandings(id: number): Promise<SeriesStandings> {
    const series = await this.findById(id);
    if (!series) {
      throw new Error("Series not found");
    }

    // Get all competitions in the series
    const competitionsStmt = this.db.prepare(`
      SELECT c.id, c.name, c.date
      FROM competitions c
      WHERE c.series_id = ?
      ORDER BY c.date
    `);
    const competitions = competitionsStmt.all(id) as any[];

    // Get team results for each competition
    const teamStandings: { [teamId: number]: SeriesTeamStanding } = {};

    for (const competition of competitions) {
      // Calculate team results for this competition using the same logic as competition leaderboard
      const teamResults = await this.calculateCompetitionTeamResults(
        competition.id
      );

      for (const teamResult of teamResults) {
        if (!teamStandings[teamResult.team_id]) {
          teamStandings[teamResult.team_id] = {
            team_id: teamResult.team_id,
            team_name: teamResult.team_name,
            total_points: 0,
            competitions_played: 0,
            position: 0,
            competitions: [],
          };
        }

        teamStandings[teamResult.team_id].total_points += teamResult.points;
        teamStandings[teamResult.team_id].competitions_played += 1;
        teamStandings[teamResult.team_id].competitions.push({
          competition_id: competition.id,
          competition_name: competition.name,
          competition_date: competition.date,
          points: teamResult.points,
          position: teamResult.position,
        });
      }
    }

    // Sort teams by total points (descending) and assign positions
    const sortedTeams = Object.values(teamStandings)
      .sort((a, b) => b.total_points - a.total_points)
      .map((team, index) => ({
        ...team,
        position: index + 1,
      }));

    return {
      series,
      team_standings: sortedTeams,
      total_competitions: competitions.length,
    };
  }

  private async calculateCompetitionTeamResults(
    competitionId: number
  ): Promise<any[]> {
    // Get all participants for this competition
    const participantsStmt = this.db.prepare(`
      SELECT p.*, tm.name as team_name, tm.id as team_id
      FROM participants p
      JOIN tee_times t ON p.tee_time_id = t.id
      JOIN teams tm ON p.team_id = tm.id
      WHERE t.competition_id = ?
      ORDER BY t.teetime, p.tee_order
    `);
    const participants = participantsStmt.all(competitionId) as any[];

    // Get course pars for score calculation
    const courseStmt = this.db.prepare(`
      SELECT co.pars
      FROM competitions c
      JOIN courses co ON c.course_id = co.id
      WHERE c.id = ?
    `);
    const courseResult = courseStmt.get(competitionId) as any;
    const coursePars = JSON.parse(courseResult.pars);

    // Calculate individual scores
    const participantScores = participants.map((participant) => {
      const scores = JSON.parse(participant.score || "[]");
      let totalShots = 0;
      let totalPlayedPar = 0;
      let holesPlayed = 0;
      const hasGaveUp = scores.some((score: number) => score === -1);

      if (!hasGaveUp) {
        for (let i = 0; i < Math.min(scores.length, coursePars.length); i++) {
          const score = scores[i];
          const par = coursePars[i];
          if (score && score > 0) {
            totalShots += score;
            totalPlayedPar += par;
            holesPlayed++;
          }
        }
      }

      return {
        participant,
        totalShots: hasGaveUp ? 0 : totalShots,
        relativeToPar: hasGaveUp ? 0 : totalShots - totalPlayedPar,
        holesPlayed: hasGaveUp ? 0 : holesPlayed,
        isValidRound: !hasGaveUp,
      };
    });

    // Group by team and calculate team totals
    const teamGroups: { [teamName: string]: any } = {};

    participantScores.forEach((entry) => {
      const teamName = entry.participant.team_name;
      const teamId = entry.participant.team_id;

      if (!teamGroups[teamName]) {
        teamGroups[teamName] = {
          team_id: teamId,
          team_name: teamName,
          participants: [],
          totalShots: 0,
          relativeToPar: 0,
        };
      }

      teamGroups[teamName].participants.push({
        name: entry.participant.player_names || "",
        position: entry.participant.position_name,
        totalShots: entry.totalShots,
        relativeToPar: entry.relativeToPar,
      });

      teamGroups[teamName].totalShots += entry.totalShots;
      teamGroups[teamName].relativeToPar += entry.relativeToPar;
    });

    // Sort teams by relativeToPar and assign points
    return Object.values(teamGroups)
      .sort((a, b) => a.relativeToPar - b.relativeToPar)
      .map((team, index, array) => {
        const position = index + 1;
        let points = array.length - position + 1; // Base points (last place gets 1 point)

        // Add extra points for top 3 positions
        if (position === 1) points += 2; // First place gets 2 extra points
        if (position === 2) points += 1; // Second place gets 1 extra point

        return {
          ...team,
          position,
          points,
        };
      });
  }
}

```

# src/services/team-service.ts

```ts
import { Database } from "bun:sqlite";
import type { CreateTeamDto, Team, UpdateTeamDto } from "../types";

export class TeamService {
  constructor(private db: Database) {}

  async create(data: CreateTeamDto): Promise<Team> {
    if (!data.name?.trim()) {
      throw new Error("Team name is required");
    }

    try {
      const stmt = this.db.prepare(`
        INSERT INTO teams (name, created_at, updated_at)
        VALUES (?, strftime('%Y-%m-%d %H:%M:%S.%f', 'now'), strftime('%Y-%m-%d %H:%M:%S.%f', 'now'))
        RETURNING *
      `);

      return stmt.get(data.name) as Team;
    } catch (error) {
      if (
        error instanceof Error &&
        error.message.includes("UNIQUE constraint failed")
      ) {
        throw new Error("Team name must be unique");
      }
      throw error;
    }
  }

  async findAll(): Promise<Team[]> {
    const stmt = this.db.prepare(
      "SELECT id, name, created_at, updated_at FROM teams"
    );
    return stmt.all() as Team[];
  }

  async findById(id: number): Promise<Team | null> {
    const stmt = this.db.prepare(
      "SELECT id, name, created_at, updated_at FROM teams WHERE id = ?"
    );
    return stmt.get(id) as Team | null;
  }

  async update(id: number, data: UpdateTeamDto): Promise<Team> {
    if (data.name !== undefined && !data.name.trim()) {
      throw new Error("Team name cannot be empty");
    }

    const updates: string[] = [];
    const values: any[] = [];

    if (data.name !== undefined) {
      updates.push("name = ?");
      values.push(data.name);
    }

    if (updates.length === 0) {
      const team = await this.findById(id);
      if (!team) {
        throw new Error("Team not found");
      }
      return team;
    }

    updates.push("updated_at = strftime('%Y-%m-%d %H:%M:%S.%f', 'now')");
    values.push(id);

    try {
      const stmt = this.db.prepare(`
        UPDATE teams 
        SET ${updates.join(", ")}
        WHERE id = ?
        RETURNING *
      `);

      const team = stmt.get(...values) as Team | null;
      if (!team) {
        throw new Error("Team not found");
      }

      return team;
    } catch (error) {
      if (
        error instanceof Error &&
        error.message.includes("UNIQUE constraint failed")
      ) {
        throw new Error("Team name must be unique");
      }
      throw error;
    }
  }
}

```

# src/services/tee-time-service.ts

```ts
import { Database } from "bun:sqlite";
import type {
  CreateTeeTimeDto,
  Participant,
  TeeTime,
  TeeTimeWithParticipants,
  UpdateTeeTimeDto,
} from "../types";

export class TeeTimeService {
  constructor(private db: Database) {}

  async create(data: CreateTeeTimeDto): Promise<TeeTime> {
    if (!data.teetime?.trim()) {
      throw new Error("Tee time is required");
    }

    // Verify competition exists
    const competitionStmt = this.db.prepare(
      "SELECT id FROM competitions WHERE id = ?"
    );
    const competition = competitionStmt.get(data.competition_id);
    if (!competition) {
      throw new Error("Competition not found");
    }

    const stmt = this.db.prepare(`
      INSERT INTO tee_times (teetime, competition_id)
      VALUES (?, ?)
      RETURNING *
    `);

    return stmt.get(data.teetime, data.competition_id) as TeeTime;
  }

  async findAllForCompetition(competitionId: number): Promise<TeeTime[]> {
    // Verify competition exists
    const competitionStmt = this.db.prepare(
      "SELECT id FROM competitions WHERE id = ?"
    );
    const competition = competitionStmt.get(competitionId);
    if (!competition) {
      throw new Error("Competition not found");
    }

    const stmt = this.db.prepare(
      "SELECT * FROM tee_times WHERE competition_id = ? order by teetime"
    );
    return stmt.all(competitionId) as TeeTime[];
  }

  async findAllForCompetitionWithParticipants(
    competitionId: number
  ): Promise<TeeTimeWithParticipants[]> {
    // Verify competition exists
    const competitionStmt = this.db.prepare(
      "SELECT id FROM competitions WHERE id = ?"
    );
    const competition = competitionStmt.get(competitionId);
    if (!competition) {
      throw new Error("Competition not found");
    }

    // Get all tee times for the competition with course info
    const teeTimesStmt = this.db.prepare(`
      SELECT t.*, co.name as course_name, co.pars
      FROM tee_times t
      JOIN competitions c ON t.competition_id = c.id
      JOIN courses co ON c.course_id = co.id
      WHERE t.competition_id = ?
      ORDER BY t.teetime
    `);
    const teeTimes = teeTimesStmt.all(competitionId) as (TeeTime & {
      course_name: string;
      pars: string;
    })[];

    // Get all participants for each tee time
    const participantsStmt = this.db.prepare(`
      SELECT p.*, t.name as team_name 
      FROM participants p
      LEFT JOIN teams t ON p.team_id = t.id
      WHERE p.tee_time_id = ?
      ORDER BY p.tee_order
    `);

    const teeTimesWithParticipants: TeeTimeWithParticipants[] = teeTimes.map(
      (teeTime) => {
        const participants = participantsStmt.all(
          teeTime.id
        ) as (Participant & { team_name?: string })[];

        // Parse the score field for each participant
        const parsedParticipants = participants.map((p) => ({
          ...p,
          score:
            typeof p.score === "string" ? JSON.parse(p.score) : p.score || [],
        }));

        // Parse course pars
        const pars = JSON.parse(teeTime.pars);

        return {
          ...teeTime,
          course_name: teeTime.course_name,
          pars,
          participants: parsedParticipants,
        };
      }
    );

    return teeTimesWithParticipants;
  }

  async findById(id: number): Promise<TeeTime | null> {
    const stmt = this.db.prepare("SELECT * FROM tee_times WHERE id = ?");
    return stmt.get(id) as TeeTime | null;
  }

  async findByIdWithParticipants(
    id: number
  ): Promise<TeeTimeWithParticipants | null> {
    // Get tee time with course information
    const teeTimeStmt = this.db.prepare(`
      SELECT t.*, co.name as course_name, co.pars
      FROM tee_times t
      JOIN competitions c ON t.competition_id = c.id
      JOIN courses co ON c.course_id = co.id
      WHERE t.id = ?
    `);
    const teeTimeWithCourse = teeTimeStmt.get(id) as
      | (TeeTime & { course_name: string; pars: string })
      | null;
    if (!teeTimeWithCourse) return null;

    // Get all participants for this tee time
    const participantsStmt = this.db.prepare(`
      SELECT p.*, t.name as team_name 
      FROM participants p
      LEFT JOIN teams t ON p.team_id = t.id
      WHERE p.tee_time_id = ?
      ORDER BY p.tee_order
    `);

    const participants = participantsStmt.all(id) as (Participant & {
      team_name?: string;
    })[];

    // Parse the score field for each participant
    const parsedParticipants = participants.map((p) => ({
      ...p,
      score: typeof p.score === "string" ? JSON.parse(p.score) : p.score || [],
    }));

    // Parse course pars
    const pars = JSON.parse(teeTimeWithCourse.pars);

    return {
      ...teeTimeWithCourse,
      course_name: teeTimeWithCourse.course_name,
      pars,
      participants: parsedParticipants,
    };
  }

  async update(id: number, data: UpdateTeeTimeDto): Promise<TeeTime> {
    const teeTime = await this.findById(id);
    if (!teeTime) {
      throw new Error("Tee time not found");
    }

    if (data.teetime && !data.teetime.trim()) {
      throw new Error("Tee time cannot be empty");
    }

    if (data.competition_id) {
      const competitionStmt = this.db.prepare(
        "SELECT id FROM competitions WHERE id = ?"
      );
      const competition = competitionStmt.get(data.competition_id);
      if (!competition) {
        throw new Error("Competition not found");
      }
    }

    const updates: string[] = [];
    const values: any[] = [];

    if (data.teetime) {
      updates.push("teetime = ?");
      values.push(data.teetime);
    }

    if (data.competition_id) {
      updates.push("competition_id = ?");
      values.push(data.competition_id);
    }

    if (updates.length === 0) {
      return teeTime;
    }

    updates.push("updated_at = CURRENT_TIMESTAMP");
    values.push(id);

    const stmt = this.db.prepare(`
      UPDATE tee_times 
      SET ${updates.join(", ")}
      WHERE id = ?
      RETURNING *
    `);

    return stmt.get(...values) as TeeTime;
  }

  async delete(id: number): Promise<void> {
    const teeTime = await this.findById(id);
    if (!teeTime) {
      throw new Error("Tee time not found");
    }

    const stmt = this.db.prepare("DELETE FROM tee_times WHERE id = ?");
    stmt.run(id);
  }

  async updateParticipantsOrder(
    id: number,
    newOrder: number[]
  ): Promise<TeeTimeWithParticipants> {
    const teeTime = await this.findById(id);
    if (!teeTime) {
      throw new Error("Tee time not found");
    }

    // Verify that all participant IDs in newOrder belong to this tee time
    const participantsStmt = this.db.prepare(`
      SELECT id FROM participants WHERE tee_time_id = ?
    `);
    const participants = participantsStmt.all(id) as { id: number }[];
    const participantIds = participants.map((p) => p.id);
    const invalidIds = newOrder.filter((id) => !participantIds.includes(id));
    if (invalidIds.length > 0) {
      throw new Error(`Invalid participant IDs: ${invalidIds.join(", ")}`);
    }

    // Update the tee_order for each participant
    const updateStmt = this.db.prepare(`
      UPDATE participants SET tee_order = ? WHERE id = ?
    `);
    newOrder.forEach((participantId, index) => {
      updateStmt.run(index + 1, participantId);
    });

    // Return the updated tee time with participants
    const updatedTeeTime = await this.findByIdWithParticipants(id);
    if (!updatedTeeTime) {
      throw new Error("Failed to retrieve updated tee time");
    }
    return updatedTeeTime;
  }
}

```

# src/types/index.ts

```ts
export interface ParsData {
  holes: number[];
  out: number;
  in: number;
  total: number;
}

export interface Course {
  id: number;
  name: string;
  pars: ParsData;
  created_at: string;
  updated_at: string;
}

export interface Series {
  id: number;
  name: string;
  description?: string;
  banner_image_url?: string;
  is_public: boolean;
  landing_document_id?: number;
  created_at: string;
  updated_at: string;
}

export interface Team {
  id: number;
  name: string;
  created_at: string;
  updated_at: string;
}

export interface Competition {
  id: number;
  name: string;
  date: string;
  course_id: number;
  series_id?: number;
  created_at: string;
  updated_at: string;
}

export interface CreateCourseDto {
  name: string;
}

export interface UpdateCourseDto {
  name?: string;
}

export interface CreateSeriesDto {
  name: string;
  description?: string;
  banner_image_url?: string;
  is_public?: boolean;
}

export interface UpdateSeriesDto {
  name?: string;
  description?: string;
  banner_image_url?: string;
  is_public?: boolean;
  landing_document_id?: number;
}

export interface SeriesTeamStanding {
  team_id: number;
  team_name: string;
  total_points: number;
  competitions_played: number;
  position: number;
  competitions: {
    competition_id: number;
    competition_name: string;
    competition_date: string;
    points: number;
    position: number;
  }[];
}

export interface SeriesStandings {
  series: Series;
  team_standings: SeriesTeamStanding[];
  total_competitions: number;
}

export interface CreateTeamDto {
  name: string;
}

export interface UpdateTeamDto {
  name?: string;
}

export interface CreateCompetitionDto {
  name: string;
  date: string;
  course_id: number;
  series_id?: number;
}

export interface UpdateCompetitionDto {
  name?: string;
  date?: string;
  course_id?: number;
  series_id?: number;
}

export interface TeeTime {
  id: number;
  teetime: string;
  competition_id: number;
  created_at: string;
  updated_at: string;
}

export interface TeeTimeWithParticipants {
  id: number;
  teetime: string;
  competition_id: number;
  created_at: string;
  updated_at: string;
  course_name: string;
  pars: ParsData;
  participants: Participant[];
}

export interface Participant {
  id: number;
  tee_order: number;
  team_id: number;
  tee_time_id: number;
  position_name: string;
  player_names?: string;
  score: number[];
  created_at: string;
  updated_at: string;
}

export interface CreateTeeTimeDto {
  teetime: string;
  competition_id: number;
}

export interface UpdateTeeTimeDto {
  teetime?: string;
  competition_id?: number;
}

export interface CreateParticipantDto {
  tee_order: number;
  team_id: number;
  tee_time_id: number;
  position_name: string;
  player_names?: string;
}

export interface UpdateParticipantDto {
  tee_order?: number;
  team_id?: number;
  tee_time_id?: number;
  position_name?: string;
  player_names?: string;
}

export interface LeaderboardEntry {
  participant: Participant;
  totalShots: number;
  holesPlayed: number;
  relativeToPar: number;
}

export interface Document {
  id: number;
  title: string;
  content: string;
  type: string;
  series_id: number;
  created_at: string;
  updated_at: string;
}

export interface CreateDocumentDto {
  title: string;
  content: string;
  type: string;
  series_id: number;
}

export interface UpdateDocumentDto {
  title?: string;
  content?: string;
  type?: string;
}

export interface CreateSeriesDocumentDto {
  title: string;
  content: string;
}

export interface UpdateSeriesDocumentDto {
  title?: string;
  content?: string;
}

```

# tsconfig.json

```json
{
  "compilerOptions": {
    // Enable latest features
    "lib": ["ESNext", "DOM"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,

    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,

    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false
  }
}

```

